<html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      .legend span {
        margin-right: 10px;
      }
        
      .gridlines line {
        stroke: #bbb;
      }
      
      .gridlines .domain {
        stroke: none;
      }

      .barlabel20 {
        writing-mode: vertical-rl;
        text-orientation: sideways-right;

        /* /* transform-origin:  */
        /* transform: rotate(45deg); */
      }

    </style>
  </head>
  <body>
    <h3>Charlotte Verity (cev32)</h3>
      <svg id="graph1" height="500" width="800" style="background: white;">
      </svg>
      <script>
        d3.csv('data.csv', d3.autoType).then( (data) => { 
        const svg = d3.select('svg#graph1');
        const width = svg.attr('width');
        const height = svg.attr('height');
        const margins = {top: 30, right: 10, bottom: 50, left: 100};
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;
        
        let chartArea = svg.append('g')
                           .attr('transform',`translate(${margins.left},${margins.top})`);
        data = data.filter( d => d.Danceability != null)
        data = data.filter( d => d.Valence != null)
        data = data.filter( d => d.Views != null)
        data = data.filter( d => d.Likes != null)
        data = data.filter( d => d.Stream != null)
       // data = data.filter( d => d.Stream >= 1000000000)

        const valenceExtent = d3.extent(data, d => d['Valence'] );
        const valenceScale = d3.scaleLinear().domain(valenceExtent).range([chartHeight, 0]);
        
        const danceabilityExtent = d3.extent(data, d => d['Danceability'] );
        const danceabilityScale = d3.scaleLinear().domain(danceabilityExtent)
                            .range([0, chartWidth]);

        const viewsExtent = d3.extent(data, d => d['Views'] );
        const viewsScale = d3.scaleLinear().domain(viewsExtent)
                            .range([0, 10]);



        let leftAxis = d3.axisLeft(valenceScale); 
        svg.append('g')
          .attr('class', 'y axis')
          .attr('transform',`translate(${margins.left-10},${margins.top})`) 
          .call(leftAxis);
        let bottomAxis = d3.axisBottom(danceabilityScale).ticks(6)
        svg.append('g')
          .attr('class', 'y axis')
          .attr('transform',`translate(${margins.left},${chartHeight+margins.top+10})`)
          .call(bottomAxis);
        let leftGridlines = d3.axisLeft(valenceScale)
          .tickSize(-chartWidth-10)
          .tickFormat('');
        svg.append('g')
          .attr('class', 'y gridlines')
          .attr('transform',`translate(${margins.left-10},${margins.top})`)
          .lower()
          .call(leftGridlines);        
        let bottomGridlines = d3.axisBottom(danceabilityScale)
          .tickSize(-chartHeight-10)
          .tickFormat('')
          .ticks(6);
        svg.append('g')
          .attr('class', 'x gridlines')
          .attr('transform',`translate(${margins.left},${chartHeight+margins.top+10})`)
          .lower()
          .call(bottomGridlines);

        svg.append("text")
          .attr("class", "title")
          .attr("text-anchor", "end")
          .attr("x", width/2+300)
          .attr("y", 15)
          .attr("font-family", "Arial")
          .text("Visualizing Song Valence vs. Danceability with Size Proportional to Popularity");

        svg.append("text")
          .attr("class", "x label")
          .attr("text-anchor", "end")
          .attr("x", width/2+80)
          .attr("y", height-4)
          .attr("font-family", "Arial")
          .text("Danceability");
          
        data.forEach( (d, i) => {
          chartArea.append('circle')
              .attr('cx', danceabilityScale(d['Danceability']))
              .attr('cy', valenceScale(d['Valence']))
              .attr('r', viewsScale(d['Views']))
              .attr('rad', viewsScale(d['Views']))
              .attr('class', d['Track'])
              .attr('opacity', .8)
              .attr('index', i)
              .style('fill', 'red')
              .on('mouseover', function (d, i) {
                d3.select(this).transition()
                    .duration('50')
                    .style('fill', 'blue')
                chartArea.append("text")
                  .attr("x",10)
                  .attr("y",20)
                  .style("font-size","15px")
                  .text(d3.select(this).attr("class"));
              })
              .on('mouseout', function (d, i) {
                d3.select(this).transition()
                  .duration('50')
                  .style('fill', 'red')
                chartArea.selectAll("text")
                  .remove()
              });

        });
        }, (error) => { console.log(error)} );
      </script>
      <br>
      <br>
      <br>
      <svg id="graph2" height="500" width="800" style="background: white;">
      </svg>
      <script>
        d3.csv('data.csv', d3.autoType).then( (data) => { 
        const svg = d3.select('svg#graph2');
        const width = svg.attr('width');
        const height = svg.attr('height');
        const margins = {top: 30, right: 20, bottom: 50, left: 100};
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;
        
        let chartArea = svg.append('g')
                           .attr('transform',`translate(${margins.left},${margins.top})`);
        data = data.filter( d => d.Danceability != null)
        data = data.filter( d => d.Valence != null)
        data = data.filter( d => d.Views != null)
        data = data.filter( d => d.Likes != null)
        data = data.filter( d => d.Stream != null)

        const streamExtent = d3.extent(data, d => d['Stream'] );
        const streamScale = d3.scaleLinear().domain(streamExtent).range([chartHeight, 0]);
        
        const viewsExtent = d3.extent(data, d => d['Views'] );
        const viewsScale = d3.scaleLinear().domain(viewsExtent)
                            .range([0, chartWidth]);

        const durationExtent = d3.extent(data, d => d['Duration_ms'] );
        const durationScale = d3.scaleLinear().domain(durationExtent)
                            .range([0, 10]);

        console.log(durationExtent)
        console.log(streamExtent)
        console.log(viewsExtent)
        

        let leftAxis = d3.axisLeft(streamScale); 
        svg.append('g')
          .attr('class', 'y axis')
          .attr('transform',`translate(${margins.left-10},${margins.top})`) 
          .call(leftAxis);
        let bottomAxis = d3.axisBottom(viewsScale).ticks(6)
        svg.append('g')
          .attr('class', 'y axis')
          .attr('transform',`translate(${margins.left},${chartHeight+margins.top+10})`)
          .call(bottomAxis);
        let leftGridlines = d3.axisLeft(streamScale)
          .tickSize(-chartWidth-10)
          .tickFormat('');
        svg.append('g')
          .attr('class', 'y gridlines')
          .attr('transform',`translate(${margins.left-10},${margins.top})`)
          .lower()
          .call(leftGridlines);        
        let bottomGridlines = d3.axisBottom(viewsScale)
          .tickSize(-chartHeight-10)
          .tickFormat('')
          .ticks(6);
        svg.append('g')
          .attr('class', 'x gridlines')
          .attr('transform',`translate(${margins.left},${chartHeight+margins.top+10})`)
          .lower()
          .call(bottomGridlines);

        svg.append("text")
          .attr("class", "title")
          .attr("text-anchor", "end")
          .attr("x", width/2+300)
          .attr("y", 15)
          .attr("font-family", "Arial")
          .text("Visualizing Youtube Views vs. Spotify Streams with Size Proportional to Duration");

        svg.append("text")
          .attr("class", "x label")
          .attr("text-anchor", "end")
          .attr("x", width/2+80)
          .attr("y", height-4)
          .attr("font-family", "Arial")
          .text("Views");
          
        data.forEach( (d, i) => {
          chartArea.append('circle')
              .attr('cx', viewsScale(d['Views']))
              .attr('cy', streamScale(d['Stream']))
              .attr('r', durationScale(d['Duration_ms']))
              .attr('class', d['Track'])
              .attr('opacity', .8)
              .attr('index', i)
              .style('fill', 'green') //TODO: does mousover count as interaction
              .on('mouseover', function (d, i) {
                d3.select(this).transition()
                    .duration('50')
                    .style('fill', 'blue')
                chartArea.append("text")
                  .attr("x",10)
                  .attr("y",20)
                  .style("font-size","15px")
                  .text(d3.select(this).attr("class"));
              })
              .on('mouseout', function (d, i) {
                d3.select(this).transition()
                  .duration('50')
                  .style('fill', 'green')
                chartArea.selectAll("text")
                  .remove()
              });

        });
        }, (error) => { console.log(error)} );
      </script>

    <h3>Chiara Signorelli, cts92</h3>
      <svg id="graph3" height="1200" width="1200" style="background: white;"></svg>
      <script>

        d3.csv('data.csv', d3.autoType).then( (data) => { 
        const svg = d3.select('svg#graph3');
        const width = svg.attr('width');
        const height = svg.attr('height');
        const margins = {top: 30, right: 420, bottom: 450, left: 100};
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;

        let chartArea = svg.append('g')
                           .attr('transform',`translate(${margins.left},${margins.top})`);
        data = data.filter( d => d.Danceability != null);
        data = data.filter( d => d.Valence != null);
        data = data.filter( d => d.Views != null);
        data = data.filter( d => d.Likes != null);
        data = data.filter( d => d.Stream != null);

        //choose only songs with top 20 streams + views total, must select
        //based on both track & artist bc of duplicates from features in og dataset
        let tracks20 = ['Despacito', 'Shape of You', 'See You Again (feat. Charlie Puth)', 'Uptown Funk (feat. Bruno Mars)',
                          'Thinking out Loud', 'Perfect', 'Counting Stars', 'Sorry',
                        'Sugar', 'Let Her Go', 'Faded', 'Gangnam Style (강남스타일)', 
                        'Lean On', 'Wheels on the Bus', 'Believer', 'New Rules',
                          'Roar','Sunflower - Spider-Man: Into the Spider-Verse', 'Dark Horse', 'Mi Gente'];

        let artists20 = ['Luis Fonsi', 'Ed Sheeran', 'Charlie Puth', 'Mark Ronson',
                        'Ed Sheeran', 'Ed Sheeran', 'OneRepublic', 'Justin Bieber',
                          'Maroon 5', 'Passenger', 'Alan Walker', 'PSY',
                        'MØ', 'CoComelon', 'Imagine Dragons', 'Dua Lipa',
                        'Katy Perry', 'Post Malone', 'Katy Perry', 'Willy William'];
        

    

        let data20 = [];
        data.forEach(d => {

          track_i = tracks20.indexOf(d['Track']);
          artist_i = artists20.indexOf(d['Artist']);

          if(track_i > -1 && artist_i > -1 && track_i == artist_i){
            data20.push(d);
          };

          //pushing Thinking Out Loud, Perfect, and Dark Horse directly
          if(d['Track'] == 'Thinking out Loud' && d['Artist'] == 'Ed Sheeran'){
            data20.push(d);
          };

          if(d['Track'] == 'Perfect' && d['Artist'] == 'Ed Sheeran'){
            data20.push(d);
          };

          if(d['Track'] == 'Dark Horse' && d['Artist'] == 'Katy Perry'){
            data20.push(d);
          };


        });

        //pick sort order

        //sorting based on total # of streams + views, in descending order (most popular on top)
        //data20.sort( (a,b) => (b['Stream'] + b['Views']) - (a['Stream'] + a['Views']));

        //sorting based on danceability buckets, in ascending order (least danceable on top/to the left )
        data20.sort((a,b) => a['Danceability'] - b['Danceability']);

        console.log("DATA20");
        console.log(data20);

        const widthScale = d3.scaleLinear().domain([0,1]).range([0, chartWidth]);
        const heightScale = d3.scaleLinear().domain([0,1]).range([0, chartHeight]);

        data20.forEach( (d,i) => {
          //get stream % and view % - total bar adds up to 1
          let denom = d['Stream'] + d['Views'];
          let p_stream = d['Stream'] / denom;
          let p_views = d['Views'] / denom;

          //assign bars a color scheme based on danceability bucket
          let streamStroke = "gray";
          let viewsStroke = "black";
          let db = d['Danceability'];

          //TODO: get better stroke colors
          let viewsStrokes = ['#DAF42B', '#8CF246', '#F8A93F', '#5B81F1', '#8F77E9', '#F577F0', '#F4604E', '#1828B1', '#7C4955', '#EB3EC3'];
          let streamStrokes = ['#BED236', '#54A51D', '#C78021', '##2D4A9E', '#3A209B', '#962491', '#AE3527', '#0D1766', '#4A121F', '#89126D' ];
          //FOR VARSHA: lower bound of bucket is inclusive, upper bound is exclusive
          if(db >= 0 && db < 0.1) { streamStroke = streamStrokes[0]; viewsStroke = viewsStrokes[0];};
          if(db >= 0.1 && db < 0.2) { streamStroke = streamStrokes[1]; viewsStroke = viewsStrokes[1];};
          if(db >= 0.2 && db < 0.3) { streamStroke = streamStrokes[2]; viewsStroke = viewsStrokes[2];};
          if(db >= 0.3 && db < 0.4) { streamStroke = streamStrokes[3]; viewsStroke = viewsStrokes[3];};
          if(db >= 0.4 && db < 0.5) { streamStroke = streamStrokes[4]; viewsStroke = viewsStrokes[4];};
          if(db >= 0.5 && db < 0.6) { streamStroke = streamStrokes[5]; viewsStroke = viewsStrokes[5];};
          if(db >= 0.6 && db < 0.7) { streamStroke = streamStrokes[6]; viewsStroke = viewsStrokes[6];};
          if(db >= 0.7 && db < 0.8) { streamStroke = streamStrokes[7]; viewsStroke = viewsStrokes[7];};
          if(db >= 0.8 && db < 0.9) { streamStroke = streamStrokes[8]; viewsStroke = viewsStrokes[8];};
          if(db >= 0.9 && db <= 1) { streamStroke = streamStrokes[9]; viewsStroke = viewsStrokes[9];};




          //add stream % on bottom of bar
          //to switch direction, just switch x's and y's
          let x = i*chartWidth/20 + 10;
          svg.append("line")
              .attr('id', 'streamline')
              .attr('x1', x)
              .attr('x2', x)
              .attr('y1', heightScale(1 - p_stream))
              .attr('y2', heightScale(1))
              .style("stroke", streamStroke)
              .style("stroke-width", 20);

          //labelling p_stream bar
          //TODO: center number on bar
          svg.append('text')
            .attr('x', x - 7.5)
            .attr('y', heightScale(1 - p_stream) + 25)
            .text(Math.trunc(100*p_stream))
            .style('fill', 'white');


         //add views % on top of bar 
         svg.append("line")
            .attr('id', 'viewsline')
            .attr('x1', x)
            .attr('x2', x)
            .attr('y1', heightScale(0))
            .attr('y2', heightScale(1 - p_stream))
            .style('stroke', viewsStroke)
            .style('stroke-width', 20);

        //labelling p_views bar
        //TODO: center number on bar
        svg.append('text')
            .attr('x', x - 7.5)
            .attr('y', heightScale(1 - p_stream) - 10)
            .text(100 - Math.trunc(100*p_stream))
            .style('fill', 'white');

        //TODO: fix label locations
        //adding song names as labels

        let originx = x - 7.5;
        let originy = chartHeight + 10;
        svg.append('text')
          .attr("class", "barlabel20")
          .attr('x', x - 7.5)
          .attr('y', chartHeight + 10)
          //.style('transform-origin', "top left")
          //.style('transform', 'rotate(45deg)')
          //.text(d['Track'] + " - " + d['Artist'] + " - Danceability:" + d["Danceability"])
          .text(d['Track'] + " - " + d['Artist']);

        });

        //TODO: get title to be in right spot
        //add chart title
        svg.append('text')
          .attr("text-anchor", "end")
          .attr("x", chartWidth/2)
          .attr("y", 15)
          .attr("font-family", "Arial")
          .text("TIT")
          .style('fill', 'white');
            
               

        });

      </script>
  </body>
</html>